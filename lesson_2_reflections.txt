When you initialize a repository, a new directory called .git (which is
normally invisible to file explorers and can only be seen through the
command line using ls -a) is created, which keeps track of metadata
associated with all the files in that directory that records their
versioning history.

This allows you to begin working with the files in the directory within
Git and employing the version control workflows that it makes possible.


***

A staging area is different from both a working directory and a
repository. It represents an intermediate stage between the two. When you
make a new repository, before you commit some files from a working
directory into it, you first bring the files individually into the
staging area.

This allows you fine control over exactly which files are going to go
into a given commit. Without the staging area, making a commit would roll
up all the files in your working directory into the commit, which is very
often not the ideal situation, as commits should be more or less
correlated with specific logical changes.


***

You can use the staging area to make sure you have one commit per
logical change because using "git add" to move changes into the staging
area introduces an additional step that provides an opportunity to
reflect on whether your changes are commit-appropriate. 

You can use "git diff --staged" to compare what is in the staging area to
what's in your latest commit to make completely sure that what you're
about to commit makes sense. 

Similarly, you can use "git diff" w/o arguments to compare changes
you've made in your working directory w/ what is in the staging area
(which will be whatever you committed last time), for the same kind of
reason.


***

Branches would be helpful in keeping your history organized anytime you
decided to depart from the "master" branch to attempt an experimental
feature that you weren't sure would be desirable or would work well w/
the rest of the codebase. This would cause your history to be organized
in a way that would reflect a distinction b/w the "main" codebase, which
would define key basic features, and supplementary add-ons which may or
may not prove to be necessary.

Branches would also allow you to strike out on your own path with
developing a given codebase, while another developer goes on their own
path, or continues development on the master branch. Later, you could
merge your changes, and if the merge doesn't work out, you could just
roll back to the previous commit (on both branches?) just before the
merge. This allows for independent collaboration!